2683. Neighboring Bitwise XOR :- 


bool doesValidArrayExist(vector<int>& derived) {
        int n=derived.size();
        if(n==1){
            if(derived[0]==0) return true;
            else return false;
        }
        vector<int> org(n,-1);
        if(derived[n-1]==0){
            org[n-1]=0;
            org[0]=0;
            for(int i=0;i<n-2;i++){
                if(derived[i]==0){
                    org[i+1]=org[i];
                } else{
                    if(org[i]==1) org[i+1]=0;
                    else org[i+1]=1;
                }
            }
            if(derived[n-2]==0){
                if(org[n-2]==org[n-1]) return true;
                else return false;
            } else{
                if(org[n-2]==org[n-1]) return false;
                else return true;
            }
        } else{
            org[n-1]=0;
            org[0]=1;
            for(int i=0;i<n-2;i++){
                if(derived[i]==0){
                    org[i+1]=org[i];
                } else{
                    if(org[i]==1) org[i+1]=0;
                    else org[i+1]=1;
                }
            }
            if(derived[n-2]==0){
                if(org[n-2]==org[n-1]) return true;
                else return false;
            } else{
                if(org[n-2]==org[n-1]) return false;
                else return true;
            }
        }
 }



GFG : Product array puzzle :- 


vector<int> productExceptSelf(vector<int>& arr) {
        // code here
        int zeroind,zerocnt=0;
        int n=arr.size();
        for(int i=0;i<n;i++){
            if(arr[i]==0){
                zeroind=i;
                zerocnt++;
            }
        }
        int prod=1;
        for(auto x:arr){
            if(zerocnt!=1 || x!=0) prod*=x;
        }
        vector<int> ans(n);
        for(int i=0;i<n;i++){
            if(zerocnt>1) ans[i]=0;
            else if(zerocnt==1){
                if(i==zeroind) ans[i]=prod;
                else ans[i]=0;
            } else ans[i]=prod/arr[i];
        }
        return ans;
}
